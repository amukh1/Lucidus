import "import.luci"

struct Vector_int {
    v:int*,
    len:int
};

struct Vector_char {
    v:int*,
    len:int
};

struct Vector_string {
    v:int*,
    len:int
};

struct Graph {
    nodesc:int,
    edgesc:int,
    edges:int**
};

dec edgeList(G:Graph) -> int**;
def edgeList(G:Graph) -> int** {
    return G.edges;
}

dec printEdgeList (G:Graph) -> int;
// def printEdgeList (G:Graph) -> int {
//     i:int = 0;
//     goto while;
//     label while:
//     if(i == (G.edgesc)) -> {
//         goto while_end;
//     }
//     printf("%d -- %d\n", *(((**(G->edges))->(int) + i*4)->(int*)), *((((((*(G->edges)))->(int) + i*4)->(int*))->(int) + 1*4)->(int*)));
//     (ptr i) = i + 1;
//     goto while;
//     label while_end:
//     return 0;
// }

dec getEdge(G:Graph, i:int) -> int**;
def getEdge(G:Graph, i:int) -> int** {
    edge_temp:int* = (G.edges->(int) + i*4)->(int*);
    edge:int** = edge_temp->(int**);
    return edge;
}

dec getEdgeTuple(G:Graph, i:int, j:int) -> int*;
def getEdgeTuple(G:Graph, i:int, j:int) -> int* {
    // G.edges is of type int**. This is a pointer to an array of pointers to int arrays.
    // get the [i][j]th position, return the pointer to it
    // first get the ith pointer to an int array, should be of type int**. Just G.edges shifted by i*4
    edge_temp:int* = (G.edges->(int) + i*4)->(int*);
    edge:int** = edge_temp->(int**);
    
    // now we have edge, which is a pointer to an int array. We want to get the jth element of this array
    // so we dereference edge, and then shift by j*4
    p:int* = (((*edge)->(int) + j*4)->(int*));
    return p;
}

def printEdgeList (G:Graph) -> int {
    i:int = 0;
    goto while;
    label while:
    if(i == (G.edgesc)) -> {
        goto while_end;
    }
    printf("%d -- %d\n", *getEdgeTuple(G, i, 0), *getEdgeTuple(G, i, 1));
    (ptr i) = i + 1;
    goto while;
    label while_end:
    return 0;
}

struct Permutation {
    v:int*,
    len:int
};

dec new_Permutation(v:int*, len:int) -> Permutation;
def new_Permutation(v:int*, len:int) -> Permutation {
    p:Permutation = malloc(8)->(Permutation);
    p->v = v;
    p->len = len;
    return p;
}

dec permute(p:Permutation, n:int) -> int;
def permute(p:Permutation, n:int) -> int {
    return (p.v->(int) + (n-1)*4)->(int*);
}

dec printPermutation(p:Permutation) -> int;
def printPermutation(p:Permutation) -> int {
    i:int = 0;
    goto while;
    label while:
    if(i == (p.len)) -> {
        goto while_end;
    }
    printf("%d ", *(p.v->(int) + i*4)->(int*));
    (ptr i) = i + 1;
    goto while;
    label while_end:
    printf("\n");
    return 0;
}

dec isIsomorphic(G:Graph, H:Graph) -> int;
def isIsomorphic(G:Graph, H:Graph) -> int {
    // loop through every possible bijection (permutation) and see if
    // for every edge in G, (x,y), that (fx,fy) is an edge in H
    // generate bijection:
    n:int = 0;
    goto while;
    label while:
    if(n == factorial(G.nodesc)) -> {
        goto while_end;
    }
    bij: Permutation = new_Permutation(, G.nodesc);
    label while_end:
    return 0;
}