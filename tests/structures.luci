import "import.luci"

struct Vector_int {
    v:int*,
    len:int
};

struct Vector_char {
    v:int*,
    len:int
};

struct Vector_string {
    v:int*,
    len:int
};

struct Graph {
    nodesc:int,
    edgesc:int,
    edges:int**
};

dec edgeList(G:Graph) -> int**;
def edgeList(G:Graph) -> int** {
    return G.edges;
}

dec printEdgeList (G:Graph) -> int;
// def printEdgeList (G:Graph) -> int {
//     i:int = 0;
//     goto while;
//     label while:
//     if(i == (G.edgesc)) -> {
//         goto while_end;
//     }
//     printf("%d -- %d\n", *(((**(G->edges))->(int) + i*4)->(int*)), *((((((*(G->edges)))->(int) + i*4)->(int*))->(int) + 1*4)->(int*)));
//     (ptr i) = i + 1;
//     goto while;
//     label while_end:
//     return 0;
// }

dec getEdge(G:Graph, i:int) -> int**;
def getEdge(G:Graph, i:int) -> int** {
    edge_temp:int* = (G.edges->(int) + i*4)->(int*);
    edge:int** = edge_temp->(int**);
    return edge;
}

dec getEdgeTuple(G:Graph, i:int, j:int) -> int*;
def getEdgeTuple(G:Graph, i:int, j:int) -> int* {
    // G.edges is of type int**. This is a pointer to an array of pointers to int arrays.
    // get the [i][j]th position, return the pointer to it
    // first get the ith pointer to an int array, should be of type int**. Just G.edges shifted by i*4
    edge_temp:int* = (G.edges->(int) + i*4)->(int*);
    edge:int** = edge_temp->(int**);
    
    // now we have edge, which is a pointer to an int array. We want to get the jth element of this array
    // so we dereference edge, and then shift by j*4
    p:int* = (((*edge)->(int) + j*4)->(int*));
    return p;
}

def printEdgeList (G:Graph) -> int {
    i:int = 0;
    goto while_loop;
    label while_loop:
    if(i == (G.edgesc)) -> {
        goto while_loop_end;
    }
    printf("%d -- %d\n", *getEdgeTuple(G, i, 0), *getEdgeTuple(G, i, 1));
    (ptr i) = i + 1;
    goto while_loop;
    label while_loop_end:
    return 0;
}

struct Permutation {
    v:int*,
    len:int
};

dec new_Permutation(v:int*, len:int) -> Permutation;
def new_Permutation(v:int*, len:int) -> Permutation {
    p:Permutation = malloc(8)->(Permutation);
    p->v = v;
    p->len = len;
    return p;
}

dec permute(p:Permutation, i:int) -> int;
def permute(p:Permutation, i:int) -> int {
    return *(((p->v)->(int) + (i - 1)*4)->(int*));
}

dec gen_all_permutations(n:int) -> Permutation*;
def gen_all_permutations(n:int) -> Permutation* {
    // base case
    if(n == 1) -> {
        v:Permutation* = malloc(4)->(Permutation*);
        (*v)->v = malloc(4)->(int*);
        (*v)->len = 1;
        // *((v->v)->(int) + 0*4)->(int*) = 1;
        ((*v).v)[0] = 1;
        return v;
    }
    v:Permutation* = malloc(4*factorial(n))->(Permutation*);
    i:int = 1;
    // get vector for gen_all_permutations(n-1):
    last_permutations:Permutation* = malloc(4*factorial(n-1))->(Permutation*);
    (ptr last_permutations) = gen_all_permutations(n-1);
    // refactor to not use goto.
    while(i != n+1) -> {
        // mallocate (n-1)! permutations
        // put (n) in the ith spot of each of those permutations
        // fill the rest of the spots of the (n-1)! permutations with the permutations from gen_all_permutations(n-1)

        // start:
        perms:Permutation* = malloc(4*factorial(n-1))->(Permutation*);
        j:int = 1;
        while(j != (factorial(n-1)+1)) -> {
            // mallocate a new permutation
            perm:Permutation = malloc(8)->(Permutation);
            perm->v = malloc(4*n)->(int*);
            perm->len = n;
            h:int = 1;
            k:int = 1;
            while(k != (factorial(n) + 1)) -> {
                if(k == i) -> {
                    // ((perm->v)->(int) + (k - 1)*4)->(int*) = i;
                    (perm.v)[k-1] = i;
                }
                if(k != i) -> {
                // ((perm->v)->(int) + (k - 1)*4)->(int*) = permute(*(last_permutation->(Permutation) + (j - 1)*4)->(Permutation*), h);
                permutat:Permutation* = last_permutations[j-1];
                // set perm val
                (perm.v)[k-1] = *((*(last_permutations[j-1])).v)[h-1];
                // ((perm->v)->(int) + (k - 1)*4)->(int*) = *pointer_to_thing;
                // printf("pointer_to_thing: %d\n", *((*(last_permutations[j-1])).v)[h-1]);
                (ptr h) = h + 1;
                }
                (ptr k) = k + 1;
            }
            (ptr j) = j + 1;
        }
        (ptr i) = i + 1;
    }
    return v;
}


dec isEqual(G:Graph, H:Graph) -> int; // true or false (0 or 1)
def isEqual(G:Graph, H:Graph) -> int {
    if(G.nodesc != H.nodesc) -> {
        return 0;
    }
    //otherwise
    if(G.edgesc != H.edgesc) -> {
        return 0;
    }
    //otherwise
    G_edges:int** = edgeList(G);
    H_edges:int** = edgeList(H);
    // for each edge in G, there is a corresponding edge in H s.t. the endpoints are the same
    i:int = 0;
    goto while_i;
    label while_i:
    if(i == G.edgesc) -> {
        goto while_i_end;
    }
    //otherwise
    // G_edge:int* = (G_edges->(int) + i*4)->(int*);
    // G_edge_0:int = *((G_edge->(int) + 0*4)->(int*));
    // G_edge_1:int = *((G_edge->(int) + 1*4)->(int*));
    // loop thru all H edges
    j:int = 0;
    firstsMatch:int = 0;
    secondsMatch:int = 0;
    goto while_i_two;
    label while_i_two:
    if(j == H.edgesc) -> {
        goto while_i_two_end;
    }
    //otherwise
    // H_edge:int* = ((H.edges->(int) + j*4)->(int*));
    // H_edge_0:int = *H_edge;
    // H_edge_1:int = *((H_edge->(int) + 1*4)->(int*));
    // printf("G_edge_0: %d\n", G_edge_0);
    // printf("H_edge_0: %d\n", H_edge_0);
    if(*getEdgeTuple(G,i,0) == *getEdgeTuple(H,j,0)) -> {
        // printf("edge match (1)\n");
        (ptr firstsMatch) = 1;
    }
    //otherwise
    if(*getEdgeTuple(G,i,1) == *getEdgeTuple(H,j,1)) -> {
        // printf("edge match (2)\n");
        (ptr secondsMatch) = 1;
    }
    //otherwise
    if(*getEdgeTuple(G,i,0) == *getEdgeTuple(H,j,1)) -> {
        // printf("edge match (3)\n");
        (ptr firstsMatch) = 1;
    }
    //otherwise
    if(*getEdgeTuple(G,i,1) == *getEdgeTuple(H,j,0)) -> {
        // printf("edge match (4)\n");
        (ptr secondsMatch) = 1;
    }
    (ptr j) = j + 1;
    goto while_i_two;
    label while_i_two_end:
    if(firstsMatch != 1) -> {
        return 0;
    }
    //otherwise
    if(secondsMatch != 1) -> {
        return 0;
    }
    (ptr i) = i + 1;
    goto while_i;
    label while_i_end:
    return 1;
}

dec isIsomorphic(G:Graph, H:Graph) -> int; // 0 -> false, 1 -> true
// def isIsomorphic(G:Graph, H:Graph) -> int {
//     // loop through every possible bijection and see if it is an isomorphism
//     if(G.nodesc != H.nodesc) -> {
//         return 0;
//     }
//     //otherwise
//     if(G.edgesc != H.edgesc) -> {
//         return 0;
//     }

    
//     return 1;
// }
